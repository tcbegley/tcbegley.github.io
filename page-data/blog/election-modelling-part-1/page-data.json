{"componentChunkName":"component---src-templates-post-js","path":"/blog/election-modelling-part-1","result":{"data":{"mdx":{"frontmatter":{"title":"Election Modelling - Part 1","date":"04 November 2019","path":"/blog/election-modelling-part-1","author":"Tom","excerpt":"It's happening! I actually wrote a blog post. But also the UK is having a general election in December...","tags":["bayesian statistics","politics"],"coverImage":null},"id":"b811ff52-e519-5962-97ad-f489c0685384","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Election Modelling - Part 1\",\n  \"path\": \"/blog/election-modelling-part-1\",\n  \"date\": \"2019-11-04 08:00:00\",\n  \"author\": \"Tom\",\n  \"excerpt\": \"It's happening! I actually wrote a blog post. But also the UK is having a general election in December...\",\n  \"tags\": [\"bayesian statistics\", \"politics\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"It's happening! I actually wrote a blog post. But also the UK is having a\\ngeneral election in December, the third in the last five years. Over the next\\nseveral weeks we can expect an influx of analysis, predictions and statistical\\nmodels, all trying to make sense of the situation, and figure out who is likely\\nto win. How those models will work, and the types of predictions they make is\\nlikely to be very different to what they did just two years ago during the last\\ncampaign, all thanks to an extremely successful experiment run by pollster\\nYouGov. This series of blogs is about what they did.\"), mdx(\"p\", null, \"Back in 2017, when the UK last had a general election, YouGov, a major polling\\nand market research company, \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://yougov.co.uk/topics/politics/articles-reports/2017/05/31/how-yougov-model-2017-general-election-works\"\n  }), \"experimented with a new model\"), \" for\\nforecasting the election. They predicted that the most likely outcome of the\\nvote was a hung parliament, i.e. that no political party would win a majority.\\nIt's easy to forget what a bold prediction that seemed at the time. The\\nconventional wisdom was that Theresa May's conservative party was all but\\nguaranteed to win, the only question was how much by.\"), mdx(\"p\", null, \"The modelling technique YouGov used is known as \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"multi-level regression with\\npoststratification\"), \", or \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"MRP\"), \" for short. These types of models are hard to\\nunderstand, let alone to implement, but contain a lot of extremely interesting\\nideas and maths in their design. In this first post of a series of three I'll\\ntalk about the UK political system and some of the drawbacks of traditional\\npolling methods. In the next post we'll cover some technical preliminaries such\\nas Bayesian statistics and computational inference. In the last post we'll\\ndescribe how MRP itself works.\"), mdx(\"h2\", null, \"UK elections\"), mdx(\"p\", null, \"Since we'll be looking at the particular example of the 2017 United Kingdom\\ngeneral election, there are a few things we should know about the UK political\\nsystem. Brace yourself for a lightning tour.\"), mdx(\"p\", null, \"The UK is divided into geographic areas known as parliamentary constituencies.\\nCurrently there are 650: 533 in England, 40 in Wales, 59 in Scotland, and 18 in\\nNorthern Ireland, though they are periodically reviewed and redrawn. On polling\\nday, registered voters cast their vote for a candidate to represent the\\nconstinuency they are resident in. Each of the major parties typically fields a\\ncandidate in every constituency (with some exceptions). There may also be\\nindependent candidates or representatives of smaller parties running. The\\ncandidate that receives the most votes in that constituency wins a seat in the\\nHouse of Commons, the elected body of government. The party with the most seats,\\nor a coalition or parties and MPs with a majority of seats, forms a government.\\nThere is no national vote, the overall outcome of the election is decided by the\\noutcomes in these 650 local elections.\"), mdx(\"h2\", null, \"Basic polling\"), mdx(\"p\", null, \"To understand MRP and the problems it solves, it's useful to first understand\\nhow conventional polling methods work, and what their limitations are.\"), mdx(\"p\", null, \"Basic polling analysis might proceed as follows. We have a population of voters,\\nthe electorate, each of whom have their personal preferences for the parties\\nthey want to vote for. We can illustrate that as follows, where colour\\nrepresents political preference.\"), mdx(\"p\", {\n    align: \"center\"\n  }, mdx(\"img\", {\n    src: \"../images/blog/em/population.png\"\n  })), mdx(\"p\", null, \"We select a random sample of the population, and ask them what their voting\\npreference is.\"), mdx(\"p\", {\n    align: \"center\"\n  }, mdx(\"img\", {\n    src: \"../images/blog/em/population-sample.png\"\n  })), mdx(\"p\", null, \"We calculate the proportion of voters in the sample that intend to vote for each\\nparty, and use that as our estimate of the proportion of voters in the\\nelectorate that will vote for those parties.\"), mdx(\"p\", {\n    align: \"center\"\n  }, mdx(\"img\", {\n    src: \"../images/blog/em/sample.png\"\n  })), mdx(\"p\", null, \"We know from the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://en.wikipedia.org/wiki/Central_limit_theorem\"\n  }), \"Central Limit Theorem\"), \" that the more people you sample,\\nthe closer the sample proportion will get to the true proportion. In fact, we\\ncan even quantify the effect of increasing the sample size. Specifically the\\nsampling error scales like the inverse square root of the sample size, so to\\nhalve sampling error we need to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"quadruple\"), \" the sample size. Pollsters typically\\nbalance the cost of polling lots of people against the need to reduce sampling\\nerror to an amount that doesn't diminish the utility of the polls. It turns out\\na poll of about 1000 people will give you error bars of about 3% either side of\\nthe estimate, which is often a resonable balance of certainty and expense.\"), mdx(\"p\", null, \"All of the above though is predicated on a pretty major assumption, which is\\nthat the only source of error in our estimates is sampling error. In practice\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://www.stat.columbia.edu/~gelman/research/published/polling-errors.pdf\"\n  }), \"there are many other sources of error\"), \". One example is so-called\\n\\\"frame error\\\", which is error introduced to the estimates by not having a\\nrepresentative sample. For example, political preference is not evenly\\ndistributed across the electorate. Currently in the UK support for parties is\\nstrongly correlated with age. Perhaps that looks something like this\"), mdx(\"p\", {\n    align: \"center\"\n  }, mdx(\"img\", {\n    src: \"../images/blog/em/population-skew.png\"\n  })), mdx(\"p\", null, \"If the poll is more likely to reach older people, for example if we do a\\ntelephone poll and older people are more likely to have a landline, then our\\nsample could be biased.\"), mdx(\"p\", {\n    align: \"center\"\n  }, mdx(\"img\", {\n    src: \"../images/blog/em/population-skew-sample.png\"\n  })), mdx(\"p\", null, \"Which would lead to biased estimates.\"), mdx(\"p\", {\n    align: \"center\"\n  }, mdx(\"img\", {\n    src: \"../images/blog/em/sample-skew.png\"\n  })), mdx(\"h2\", null, \"Errors are not the only problem\"), mdx(\"p\", null, \"Setting aside all of these issues, there is a bigger problem. Even if we could\\neliminate all errors in our estimates, we're not really answering the right\\nquestion. We want to know who is likely to win the election, but what we're\\npredicting is national vote share. What decides the outcome is the number of\\nseats won, which is certainly correlated to national vote share, but is not the\\nsame thing. Indeed frequently when a single party wins a majority of seats, they\\ndo so with less than 50% of the votes cast, similarly smaller parties can win a\\nsignificant share of the votes without winning any seats at all.\"), mdx(\"p\", null, \"Polling companies and analysts will typically try to deal with this problem by\\nconverting a national vote share estimate to an estimate of the number of seats\\nthat a party is likely to win. One common method for doing this is the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"uniform\\nswing method\"), \", which looks at the change in vote share for each party since the\\nlast election, and applies that change uniformly to the constituency level\\nresults from the last election and calculates what the implications would be.\\nFor example, if Labour were polling 5% better than at the previous election, the\\nuniform swing method would predict that they do 5% better in every constituency.\\nSo in any constituency where they lost by 5% of the vote or less, all other\\nthings being equal, we predict that Labour wins that seat.\"), mdx(\"p\", null, \"Such methods are relatively crude, and do not accurately capture the complex\\ndynamics that can affect support for a party in different constituencies in very\\ndifferent ways. Ideally we would like to make individual forecasts in each\\nconstituency then aggregate that into a national forecast. The problem of course\\nis that there are 650 constituencies, so to conduct a robust poll of 1000 people\\nin every single one would require polling well over half a million people.\"), mdx(\"p\", null, \"We are stuck between two undesirable options:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"We can pool data from all constituencies together and model them as one. This\\napproach however fails to capture known differences in the makeup of\\nconstituencies.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"We can model each constituency separately. This approach however typcially\\nwould require more data than we can reasonably expect to be able to collect,\\nor alternatively would be subject to errors introduced by small samples\")), mdx(\"p\", null, \"Ideally we want to find a way that we can share information between\\nconstituencies to make up for the lack of data available in any particular\\nconstituency, while still making individual predictions in each constituency.\\nThis generic problem of how best to make use of information collected from\\nmultiple groups that are related but for which we want to make separate\\npredications is readily solved by hierarchical models, of which multi-level\\nregression is an example.\"), mdx(\"p\", null, \"In the next post, we'll look at some technical preliminaries so we can start to\\nunderstand how these models work.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"It's happening! I actually wrote a blog post. But also the UK is having a general election in December..."}},"pageContext":{"next":{"frontmatter":{"path":"/blog/election-modelling-part-2","title":"Election Modelling - Part 2","tags":["bayesian statistics","politics","stan"]},"fields":{"collection":"posts"},"fileAbsolutePath":"/home/runner/work/tcbegley.github.io/tcbegley.github.io/src/content/posts/election-modelling-2.md"},"previous":null}},"staticQueryHashes":["1425477374","3128451518"]}